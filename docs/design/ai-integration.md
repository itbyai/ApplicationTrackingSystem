# AI é›†æˆæ–¹æ¡ˆè®¾è®¡

## ğŸ¤– AI æœåŠ¡æ¦‚è§ˆ

### é›†æˆç›®æ ‡
1. **ç®€å†æ™ºèƒ½åˆ†æ** - æå–å…³é”®ä¿¡æ¯ï¼Œè¯„ä¼°ç®€å†è´¨é‡
2. **èŒä½æ™ºèƒ½åŒ¹é…** - åˆ†æèŒä½ä¸ç®€å†çš„åŒ¹é…åº¦
3. **ç®€å†è¯„åˆ†ç³»ç»Ÿ** - é’ˆå¯¹ç‰¹å®šèŒä½å¯¹ç®€å†æ‰“åˆ†
4. **ä¸ªæ€§åŒ–å»ºè®®** - æä¾›ç®€å†æ”¹è¿›å’ŒèŒä¸šå‘å±•å»ºè®®

### AI æœåŠ¡æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‰ç«¯åº”ç”¨       â”‚    â”‚   åç«¯API       â”‚    â”‚   AIæœåŠ¡å±‚      â”‚
â”‚                â”‚    â”‚                â”‚    â”‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ AIåˆ†æé¡µ  â”‚   â”‚â”€â”€â”€â”€â”¤  â”‚ AIæ§åˆ¶å™¨  â”‚   â”‚â”€â”€â”€â”€â”¤  â”‚ OpenAI   â”‚   â”‚
â”‚  â”‚          â”‚   â”‚    â”‚  â”‚          â”‚   â”‚    â”‚  â”‚  API     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚    â”‚                â”‚    â”‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ åŒ¹é…ç»“æœ  â”‚   â”‚    â”‚  â”‚ ä¸šåŠ¡é€»è¾‘  â”‚   â”‚    â”‚  â”‚ æç¤ºå·¥ç¨‹  â”‚   â”‚
â”‚  â”‚ æ˜¾ç¤º     â”‚   â”‚    â”‚  â”‚ å¤„ç†     â”‚   â”‚    â”‚  â”‚ æ¨¡å—     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â”‚                       â”‚                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç¼“å­˜å±‚        â”‚    â”‚   é˜Ÿåˆ—å¤„ç†       â”‚    â”‚   ç»“æœå­˜å‚¨       â”‚
â”‚  (Redis)       â”‚    â”‚  (Bull/Bee)     â”‚    â”‚ (PostgreSQL)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§  OpenAI API é›†æˆ

### API é…ç½®
```typescript
// config/ai.ts
export const aiConfig = {
  openai: {
    apiKey: process.env.OPENAI_API_KEY,
    organization: process.env.OPENAI_ORG_ID,
    model: {
      primary: 'gpt-4-turbo-preview',
      fallback: 'gpt-3.5-turbo',
      embedding: 'text-embedding-3-small'
    },
    maxTokens: {
      analysis: 4000,
      matching: 3000,
      suggestions: 2000
    },
    temperature: 0.3,
    timeout: 30000
  },
  rateLimits: {
    perUser: {
      hour: 50,    // æ¯ç”¨æˆ·æ¯å°æ—¶50æ¬¡è¯·æ±‚
      day: 200     // æ¯ç”¨æˆ·æ¯å¤©200æ¬¡è¯·æ±‚
    },
    global: {
      minute: 100, // å…¨å±€æ¯åˆ†é’Ÿ100æ¬¡è¯·æ±‚
      hour: 1000   // å…¨å±€æ¯å°æ—¶1000æ¬¡è¯·æ±‚
    }
  }
};
```

### AI æœåŠ¡åŸºç¡€ç±»
```typescript
// services/aiService.ts
import { OpenAI } from 'openai';
import { aiConfig } from '../config/ai';

export class AIService {
  private openai: OpenAI;
  private cache: Redis;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: aiConfig.openai.apiKey,
      organization: aiConfig.openai.organization
    });
    this.cache = new Redis(process.env.REDIS_URL);
  }
  
  /**
   * é€šç”¨AIè¯·æ±‚æ–¹æ³•
   */
  private async makeAIRequest(
    messages: OpenAI.Chat.ChatCompletionMessageParam[],
    options: {
      model?: string;
      maxTokens?: number;
      temperature?: number;
      responseFormat?: 'json' | 'text';
    } = {}
  ): Promise<string> {
    try {
      const response = await this.openai.chat.completions.create({
        model: options.model || aiConfig.openai.model.primary,
        messages,
        max_tokens: options.maxTokens || aiConfig.openai.maxTokens.analysis,
        temperature: options.temperature || aiConfig.openai.temperature,
        response_format: options.responseFormat === 'json' 
          ? { type: 'json_object' }
          : undefined
      });
      
      return response.choices[0]?.message?.content || '';
    } catch (error) {
      // å¦‚æœä¸»æ¨¡å‹å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ¨¡å‹
      if (options.model !== aiConfig.openai.model.fallback) {
        return this.makeAIRequest(messages, {
          ...options,
          model: aiConfig.openai.model.fallback
        });
      }
      throw error;
    }
  }
  
  /**
   * ç”Ÿæˆç¼“å­˜é”®
   */
  private generateCacheKey(type: string, data: any): string {
    const hash = crypto
      .createHash('md5')
      .update(JSON.stringify(data))
      .digest('hex');
    return `ai:${type}:${hash}`;
  }
}
```

## ğŸ“ ç®€å†åˆ†ææ¨¡å—

### ç®€å†åˆ†ææç¤ºè¯
```typescript
// prompts/resumeAnalysis.ts
export const RESUME_ANALYSIS_PROMPT = `
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç®€å†åˆ†æä¸“å®¶ã€‚è¯·ä»”ç»†åˆ†æä»¥ä¸‹ç®€å†å†…å®¹ï¼Œå¹¶ä»¥JSONæ ¼å¼è¿”å›è¯¦ç»†çš„åˆ†æç»“æœã€‚

åˆ†æè¦æ±‚ï¼š
1. æå–ä¸ªäººåŸºæœ¬ä¿¡æ¯
2. è¯†åˆ«æ‰€æœ‰æŠ€èƒ½å’ŒæŠ€æœ¯æ ˆ
3. åˆ†æå·¥ä½œç»éªŒå’Œé¡¹ç›®ç»éªŒ
4. è¯„ä¼°æ•™è‚²èƒŒæ™¯
5. è¯†åˆ«è¯ä¹¦å’Œæˆå°±
6. åˆ†æç®€å†çš„æ•´ä½“è´¨é‡

è¯·æŒ‰ç…§ä»¥ä¸‹JSONç»“æ„è¿”å›ç»“æœï¼š
{
  "personalInfo": {
    "name": "å§“å",
    "email": "é‚®ç®±",
    "phone": "ç”µè¯",
    "location": "åœ°å€",
    "linkedin": "LinkedIné“¾æ¥",
    "github": "GitHubé“¾æ¥"
  },
  "summary": "ç®€å†æ‘˜è¦",
  "skills": [
    {
      "name": "æŠ€èƒ½åç§°",
      "category": "æŠ€èƒ½åˆ†ç±»",
      "level": "ç†Ÿç»ƒç¨‹åº¦",
      "yearsExperience": ä½¿ç”¨å¹´é™
    }
  ],
  "experience": [
    {
      "company": "å…¬å¸åç§°",
      "position": "èŒä½",
      "duration": "å·¥ä½œæ—¶é—´",
      "description": "å·¥ä½œæè¿°",
      "achievements": ["æˆå°±1", "æˆå°±2"]
    }
  ],
  "projects": [
    {
      "name": "é¡¹ç›®åç§°",
      "description": "é¡¹ç›®æè¿°",
      "technologies": ["æŠ€æœ¯1", "æŠ€æœ¯2"],
      "role": "æ‹…ä»»è§’è‰²"
    }
  ],
  "education": [
    {
      "school": "å­¦æ ¡åç§°",
      "degree": "å­¦ä½",
      "major": "ä¸“ä¸š",
      "duration": "å°±è¯»æ—¶é—´",
      "gpa": "ç»©ç‚¹"
    }
  ],
  "certifications": ["è¯ä¹¦1", "è¯ä¹¦2"],
  "languages": [
    {
      "language": "è¯­è¨€",
      "proficiency": "ç†Ÿç»ƒç¨‹åº¦"
    }
  ],
  "analysis": {
    "strengths": ["ä¼˜åŠ¿1", "ä¼˜åŠ¿2"],
    "weaknesses": ["ä¸è¶³1", "ä¸è¶³2"],
    "suggestions": ["å»ºè®®1", "å»ºè®®2"],
    "overallScore": 85,
    "scoreBreakdown": {
      "format": 90,
      "content": 85,
      "experience": 80,
      "skills": 88,
      "education": 85
    }
  }
}

ç®€å†å†…å®¹ï¼š
`;
```

### ç®€å†åˆ†ææœåŠ¡å®ç°
```typescript
// services/resumeAnalysisService.ts
export class ResumeAnalysisService extends AIService {
  /**
   * åˆ†æç®€å†å†…å®¹
   */
  async analyzeResume(resumeContent: string, userId: string): Promise<ResumeAnalysis> {
    // æ£€æŸ¥ç¼“å­˜
    const cacheKey = this.generateCacheKey('resume_analysis', { resumeContent });
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // æ£€æŸ¥ç”¨æˆ·é€Ÿç‡é™åˆ¶
    await this.checkRateLimit(userId, 'analysis');
    
    try {
      // æ„å»ºæç¤ºè¯
      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: 'system',
          content: RESUME_ANALYSIS_PROMPT
        },
        {
          role: 'user',
          content: resumeContent
        }
      ];
      
      // è°ƒç”¨AI API
      const response = await this.makeAIRequest(messages, {
        maxTokens: aiConfig.openai.maxTokens.analysis,
        responseFormat: 'json'
      });
      
      // è§£æå“åº”
      const analysis: ResumeAnalysis = JSON.parse(response);
      
      // éªŒè¯å’Œæ¸…ç†æ•°æ®
      const cleanedAnalysis = this.validateAndCleanAnalysis(analysis);
      
      // ç¼“å­˜ç»“æœï¼ˆ1å°æ—¶ï¼‰
      await this.cache.setex(cacheKey, 3600, JSON.stringify(cleanedAnalysis));
      
      // è®°å½•ä½¿ç”¨æƒ…å†µ
      await this.recordUsage(userId, 'resume_analysis', {
        tokensUsed: this.estimateTokens(response),
        success: true
      });
      
      return cleanedAnalysis;
      
    } catch (error) {
      await this.recordUsage(userId, 'resume_analysis', {
        success: false,
        error: error.message
      });
      throw new Error('ç®€å†åˆ†æå¤±è´¥: ' + error.message);
    }
  }
  
  /**
   * éªŒè¯å’Œæ¸…ç†åˆ†æç»“æœ
   */
  private validateAndCleanAnalysis(analysis: any): ResumeAnalysis {
    // éªŒè¯å¿…éœ€å­—æ®µ
    if (!analysis.personalInfo) {
      throw new Error('åˆ†æç»“æœç¼ºå°‘ä¸ªäººä¿¡æ¯');
    }
    
    // æ¸…ç†å’Œæ ‡å‡†åŒ–æŠ€èƒ½æ•°æ®
    if (analysis.skills) {
      analysis.skills = analysis.skills.map((skill: any) => ({
        name: skill.name || '',
        category: this.standardizeSkillCategory(skill.category),
        level: this.standardizeSkillLevel(skill.level),
        yearsExperience: Math.max(0, parseInt(skill.yearsExperience) || 0)
      }));
    }
    
    // éªŒè¯è¯„åˆ†
    if (analysis.analysis?.overallScore) {
      analysis.analysis.overallScore = Math.min(100, Math.max(0, analysis.analysis.overallScore));
    }
    
    return analysis;
  }
  
  /**
   * æ ‡å‡†åŒ–æŠ€èƒ½åˆ†ç±»
   */
  private standardizeSkillCategory(category: string): string {
    const categoryMap: Record<string, string> = {
      'ç¼–ç¨‹è¯­è¨€': 'PROGRAMMING_LANGUAGE',
      'æ¡†æ¶': 'FRAMEWORK',
      'æ•°æ®åº“': 'DATABASE',
      'å·¥å…·': 'TOOL',
      'è½¯æŠ€èƒ½': 'SOFT_SKILL',
      'è¯ä¹¦': 'CERTIFICATION',
      'è¯­è¨€': 'LANGUAGE'
    };
    
    return categoryMap[category] || 'OTHER';
  }
  
  /**
   * æ ‡å‡†åŒ–æŠ€èƒ½æ°´å¹³
   */
  private standardizeSkillLevel(level: string): string {
    const levelMap: Record<string, string> = {
      'åˆçº§': 'BEGINNER',
      'ä¸­çº§': 'INTERMEDIATE', 
      'é«˜çº§': 'ADVANCED',
      'ä¸“å®¶': 'EXPERT'
    };
    
    return levelMap[level] || 'INTERMEDIATE';
  }
}
```

## ğŸ¯ èŒä½åŒ¹é…æ¨¡å—

### èŒä½åŒ¹é…æç¤ºè¯
```typescript
// prompts/jobMatching.ts
export const JOB_MATCHING_PROMPT = `
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„èŒä½åŒ¹é…ä¸“å®¶ã€‚è¯·åˆ†æç®€å†ä¸èŒä½æè¿°çš„åŒ¹é…ç¨‹åº¦ï¼Œå¹¶æä¾›è¯¦ç»†çš„åŒ¹é…æŠ¥å‘Šã€‚

åˆ†æç»´åº¦ï¼š
1. æŠ€èƒ½åŒ¹é…åº¦ - ç®€å†æŠ€èƒ½ä¸èŒä½è¦æ±‚çš„åŒ¹é…ç¨‹åº¦
2. ç»éªŒåŒ¹é…åº¦ - å·¥ä½œç»éªŒä¸èŒä½ç»éªŒè¦æ±‚çš„åŒ¹é…
3. æ•™è‚²èƒŒæ™¯åŒ¹é…åº¦ - å­¦å†ä¸ä¸“ä¸šçš„åŒ¹é…ç¨‹åº¦
4. åœ°ç†ä½ç½®åŒ¹é…åº¦ - å·¥ä½œåœ°ç‚¹çš„åŒ¹é…ç¨‹åº¦
5. è–ªèµ„åŒ¹é…åº¦ - æœŸæœ›è–ªèµ„ä¸èŒä½è–ªèµ„çš„åŒ¹é…

è¯·ä»¥JSONæ ¼å¼è¿”å›åŒ¹é…åˆ†æç»“æœï¼š
{
  "overallScore": 85,
  "matchDetails": {
    "skills": {
      "score": 88,
      "matched": ["JavaScript", "React", "Node.js"],
      "missing": ["Vue.js", "Docker"],
      "additional": ["TypeScript", "GraphQL"]
    },
    "experience": {
      "score": 82,
      "requiredYears": 3,
      "candidateYears": 2.5,
      "relevantExperience": ["å‰ç«¯å¼€å‘", "å…¨æ ˆå¼€å‘"]
    },
    "education": {
      "score": 90,
      "required": "æœ¬ç§‘",
      "candidate": "æœ¬ç§‘",
      "relevantMajor": true
    },
    "location": {
      "score": 95,
      "required": "åŒ—äº¬",
      "candidate": "åŒ—äº¬",
      "remoteOption": true
    },
    "salary": {
      "score": 75,
      "requiredMin": 15000,
      "requiredMax": 25000,
      "candidateExpectation": 22000
    }
  },
  "recommendations": [
    "å»ºè®®å­¦ä¹ Vue.jsä»¥æé«˜å‰ç«¯æŠ€èƒ½åŒ¹é…åº¦",
    "å¯ä»¥å¼ºè°ƒå…¨æ ˆå¼€å‘ç»éªŒ"
  ],
  "fitLevel": "HIGH",
  "applicationPriority": "HIGH"
}

ç®€å†ä¿¡æ¯ï¼š
{resumeData}

èŒä½æè¿°ï¼š
{jobDescription}
`;
```

### èŒä½åŒ¹é…æœåŠ¡
```typescript
// services/jobMatchingService.ts
export class JobMatchingService extends AIService {
  /**
   * åˆ†æèŒä½åŒ¹é…åº¦
   */
  async analyzeJobMatch(
    resume: Resume,
    job: Job,
    userId: string
  ): Promise<JobMatchResult> {
    const cacheKey = this.generateCacheKey('job_match', {
      resumeId: resume.id,
      jobId: job.id
    });
    
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    await this.checkRateLimit(userId, 'matching');
    
    try {
      // å‡†å¤‡æ•°æ®
      const resumeData = this.extractResumeData(resume);
      const jobDescription = this.extractJobData(job);
      
      // æ„å»ºæç¤ºè¯
      const prompt = JOB_MATCHING_PROMPT
        .replace('{resumeData}', JSON.stringify(resumeData, null, 2))
        .replace('{jobDescription}', JSON.stringify(jobDescription, null, 2));
      
      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: 'system',
          content: prompt
        },
        {
          role: 'user',
          content: 'è¯·åˆ†æä»¥ä¸Šç®€å†å’ŒèŒä½çš„åŒ¹é…ç¨‹åº¦ã€‚'
        }
      ];
      
      const response = await this.makeAIRequest(messages, {
        maxTokens: aiConfig.openai.maxTokens.matching,
        responseFormat: 'json'
      });
      
      const matchResult: JobMatchResult = JSON.parse(response);
      const cleanedResult = this.validateMatchResult(matchResult);
      
      // ç¼“å­˜ç»“æœï¼ˆ30åˆ†é’Ÿï¼‰
      await this.cache.setex(cacheKey, 1800, JSON.stringify(cleanedResult));
      
      await this.recordUsage(userId, 'job_matching', {
        tokensUsed: this.estimateTokens(response),
        success: true
      });
      
      return cleanedResult;
      
    } catch (error) {
      await this.recordUsage(userId, 'job_matching', {
        success: false,
        error: error.message
      });
      throw new Error('èŒä½åŒ¹é…åˆ†æå¤±è´¥: ' + error.message);
    }
  }
  
  /**
   * æ‰¹é‡åˆ†æå¤šä¸ªèŒä½
   */
  async analyzeMultipleJobs(
    resume: Resume,
    jobs: Job[],
    userId: string
  ): Promise<JobMatchResult[]> {
    // é™åˆ¶æ‰¹é‡åˆ†æçš„æ•°é‡
    if (jobs.length > 10) {
      throw new Error('å•æ¬¡æœ€å¤šåªèƒ½åˆ†æ10ä¸ªèŒä½');
    }
    
    // å¹¶å‘æ‰§è¡Œï¼Œä½†é™åˆ¶å¹¶å‘æ•°
    const results = await Promise.allSettled(
      jobs.map(job => 
        this.analyzeJobMatch(resume, job, userId)
      )
    );
    
    return results
      .filter((result): result is PromiseFulfilledResult<JobMatchResult> => 
        result.status === 'fulfilled'
      )
      .map(result => result.value)
      .sort((a, b) => b.overallScore - a.overallScore); // æŒ‰åŒ¹é…åº¦é™åº
  }
  
  /**
   * æå–ç®€å†å…³é”®æ•°æ®
   */
  private extractResumeData(resume: Resume) {
    return {
      skills: resume.analysis?.skills || [],
      experience: resume.analysis?.experience || [],
      education: resume.analysis?.education || [],
      totalExperience: resume.totalExperience || 0,
      summary: resume.summary || ''
    };
  }
  
  /**
   * æå–èŒä½å…³é”®æ•°æ®
   */
  private extractJobData(job: Job) {
    return {
      title: job.title,
      company: job.company,
      description: job.description,
      requirements: job.requirements,
      location: job.location,
      salaryRange: {
        min: job.salaryMin,
        max: job.salaryMax
      },
      experienceLevel: job.experienceLevel,
      workType: job.workType,
      remoteOption: job.remoteOption
    };
  }
  
  /**
   * éªŒè¯åŒ¹é…ç»“æœ
   */
  private validateMatchResult(result: any): JobMatchResult {
    // éªŒè¯åˆ†æ•°èŒƒå›´
    result.overallScore = Math.min(100, Math.max(0, result.overallScore || 0));
    
    // éªŒè¯åŒ¹é…è¯¦æƒ…
    if (result.matchDetails) {
      Object.keys(result.matchDetails).forEach(key => {
        if (result.matchDetails[key]?.score) {
          result.matchDetails[key].score = Math.min(100, Math.max(0, result.matchDetails[key].score));
        }
      });
    }
    
    // è®¾ç½®åŒ¹é…ç­‰çº§
    if (result.overallScore >= 80) {
      result.fitLevel = 'HIGH';
      result.applicationPriority = 'HIGH';
    } else if (result.overallScore >= 60) {
      result.fitLevel = 'MEDIUM';
      result.applicationPriority = 'MEDIUM';
    } else {
      result.fitLevel = 'LOW';
      result.applicationPriority = 'LOW';
    }
    
    return result;
  }
}
```

## ğŸ¯ ç®€å†è¯„åˆ†ç³»ç»Ÿ

### è¯„åˆ†æœåŠ¡
```typescript
// services/resumeScoringService.ts
export class ResumeScoringService extends AIService {
  /**
   * é’ˆå¯¹ç‰¹å®šèŒä½å¯¹ç®€å†è¯„åˆ†
   */
  async scoreResumeForJob(
    resume: Resume,
    job: Job,
    userId: string
  ): Promise<ResumeScore> {
    const cacheKey = this.generateCacheKey('resume_score', {
      resumeId: resume.id,
      jobId: job.id
    });
    
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    await this.checkRateLimit(userId, 'scoring');
    
    try {
      const prompt = this.buildScoringPrompt(resume, job);
      
      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: 'system',
          content: prompt
        },
        {
          role: 'user',
          content: 'è¯·å¯¹è¿™ä»½ç®€å†è¿›è¡Œè¯¦ç»†è¯„åˆ†ã€‚'
        }
      ];
      
      const response = await this.makeAIRequest(messages, {
        maxTokens: aiConfig.openai.maxTokens.analysis,
        responseFormat: 'json'
      });
      
      const score: ResumeScore = JSON.parse(response);
      const validatedScore = this.validateScore(score);
      
      // ç¼“å­˜ç»“æœ
      await this.cache.setex(cacheKey, 1800, JSON.stringify(validatedScore));
      
      await this.recordUsage(userId, 'resume_scoring', {
        tokensUsed: this.estimateTokens(response),
        success: true
      });
      
      return validatedScore;
      
    } catch (error) {
      await this.recordUsage(userId, 'resume_scoring', {
        success: false,
        error: error.message
      });
      throw new Error('ç®€å†è¯„åˆ†å¤±è´¥: ' + error.message);
    }
  }
  
  private buildScoringPrompt(resume: Resume, job: Job): string {
    return `
    ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„HRä¸“å®¶ã€‚è¯·æ ¹æ®ä»¥ä¸‹èŒä½è¦æ±‚ï¼Œå¯¹å€™é€‰äººçš„ç®€å†è¿›è¡Œè¯¦ç»†è¯„åˆ†ã€‚

    è¯„åˆ†ç»´åº¦ï¼š
    1. æŠ€èƒ½åŒ¹é… (30%) - æŠ€èƒ½ä¸èŒä½è¦æ±‚çš„åŒ¹é…ç¨‹åº¦
    2. ç»éªŒç›¸å…³æ€§ (25%) - å·¥ä½œç»éªŒä¸èŒä½çš„ç›¸å…³ç¨‹åº¦
    3. æ•™è‚²èƒŒæ™¯ (15%) - å­¦å†å’Œä¸“ä¸šçš„åŒ¹é…ç¨‹åº¦
    4. é¡¹ç›®ç»éªŒ (20%) - é¡¹ç›®ç»éªŒçš„è´¨é‡å’Œç›¸å…³æ€§
    5. ç®€å†è´¨é‡ (10%) - ç®€å†çš„æ ¼å¼å’Œè¡¨è¾¾è´¨é‡

    è¯·ä»¥JSONæ ¼å¼è¿”å›è¯„åˆ†ç»“æœï¼š
    {
      "overallScore": 85,
      "categoryScores": {
        "skillsMatch": {
          "score": 88,
          "weight": 0.3,
          "feedback": "æŠ€èƒ½åŒ¹é…åº¦å¾ˆé«˜ï¼ŒæŒæ¡äº†å¤§éƒ¨åˆ†è¦æ±‚çš„æŠ€æœ¯"
        },
        "experienceRelevance": {
          "score": 82,
          "weight": 0.25,
          "feedback": "å·¥ä½œç»éªŒç›¸å…³ï¼Œä½†å¯ä»¥æ›´å¼ºè°ƒç›¸å…³é¡¹ç›®"
        },
        "education": {
          "score": 90,
          "weight": 0.15,
          "feedback": "æ•™è‚²èƒŒæ™¯å®Œå…¨ç¬¦åˆè¦æ±‚"
        },
        "projectExperience": {
          "score": 85,
          "weight": 0.2,
          "feedback": "é¡¹ç›®ç»éªŒä¸°å¯Œï¼Œä¸èŒä½é«˜åº¦ç›¸å…³"
        },
        "resumeQuality": {
          "score": 92,
          "weight": 0.1,
          "feedback": "ç®€å†æ ¼å¼æ¸…æ™°ï¼Œè¡¨è¾¾ç®€æ´æ˜äº†"
        }
      },
      "strengths": ["æŠ€æœ¯æ ˆå…¨é¢", "é¡¹ç›®ç»éªŒä¸°å¯Œ"],
      "improvements": ["å¯ä»¥å¢åŠ å›¢é˜Ÿåä½œç»éªŒæè¿°"],
      "hiringRecommendation": "RECOMMEND",
      "confidenceLevel": "HIGH"
    }

    èŒä½ä¿¡æ¯ï¼š
    ${JSON.stringify(this.extractJobData(job), null, 2)}

    ç®€å†ä¿¡æ¯ï¼š
    ${JSON.stringify(this.extractResumeData(resume), null, 2)}
    `;
  }
  
  private validateScore(score: any): ResumeScore {
    // éªŒè¯æ€»åˆ†
    score.overallScore = Math.min(100, Math.max(0, score.overallScore || 0));
    
    // éªŒè¯å„åˆ†ç±»è¯„åˆ†
    if (score.categoryScores) {
      Object.keys(score.categoryScores).forEach(key => {
        const category = score.categoryScores[key];
        if (category.score) {
          category.score = Math.min(100, Math.max(0, category.score));
        }
      });
    }
    
    return score;
  }
}
```

## ğŸ’¡ å»ºè®®ç”Ÿæˆç³»ç»Ÿ

### å»ºè®®ç”ŸæˆæœåŠ¡
```typescript
// services/suggestionService.ts
export class SuggestionService extends AIService {
  /**
   * ç”Ÿæˆç®€å†æ”¹è¿›å»ºè®®
   */
  async generateResumeSuggestions(
    resume: Resume,
    targetJobs: Job[],
    userId: string
  ): Promise<ResumeSuggestions> {
    const cacheKey = this.generateCacheKey('suggestions', {
      resumeId: resume.id,
      jobIds: targetJobs.map(j => j.id)
    });
    
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    await this.checkRateLimit(userId, 'suggestions');
    
    try {
      const prompt = this.buildSuggestionPrompt(resume, targetJobs);
      
      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: 'system',
          content: prompt
        },
        {
          role: 'user',
          content: 'è¯·æä¾›è¯¦ç»†çš„ç®€å†æ”¹è¿›å»ºè®®ã€‚'
        }
      ];
      
      const response = await this.makeAIRequest(messages, {
        maxTokens: aiConfig.openai.maxTokens.suggestions,
        responseFormat: 'json'
      });
      
      const suggestions: ResumeSuggestions = JSON.parse(response);
      
      // ç¼“å­˜ç»“æœï¼ˆ6å°æ—¶ï¼‰
      await this.cache.setex(cacheKey, 21600, JSON.stringify(suggestions));
      
      await this.recordUsage(userId, 'suggestions', {
        tokensUsed: this.estimateTokens(response),
        success: true
      });
      
      return suggestions;
      
    } catch (error) {
      await this.recordUsage(userId, 'suggestions', {
        success: false,
        error: error.message
      });
      throw new Error('å»ºè®®ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
  }
  
  private buildSuggestionPrompt(resume: Resume, targetJobs: Job[]): string {
    return `
    ä½ æ˜¯ä¸€ä¸ªèµ„æ·±çš„èŒä¸šå‘å±•é¡¾é—®ã€‚è¯·æ ¹æ®å€™é€‰äººçš„ç®€å†å’Œç›®æ ‡èŒä½ï¼Œæä¾›ä¸ªæ€§åŒ–çš„æ”¹è¿›å»ºè®®ã€‚

    è¯·ä»¥JSONæ ¼å¼è¿”å›å»ºè®®ï¼š
    {
      "skillDevelopment": [
        {
          "skill": "Vue.js",
          "reason": "60%çš„ç›®æ ‡èŒä½è¦æ±‚æ­¤æŠ€èƒ½",
          "priority": "HIGH",
          "learningPath": ["å®˜æ–¹æ–‡æ¡£", "å®æˆ˜é¡¹ç›®", "åœ¨çº¿è¯¾ç¨‹"],
          "timeEstimate": "2-3ä¸ªæœˆ"
        }
      ],
      "resumeImprovements": [
        {
          "section": "å·¥ä½œç»éªŒ",
          "suggestion": "æ·»åŠ é‡åŒ–æ•°æ®ï¼Œå¦‚'æå‡é¡µé¢åŠ è½½é€Ÿåº¦30%'",
          "priority": "MEDIUM",
          "impact": "æé«˜ç®€å†è¯´æœåŠ›"
        }
      ],
      "careerAdvice": [
        {
          "advice": "è€ƒè™‘å‘å…¨æ ˆå¼€å‘æ–¹å‘å‘å±•",
          "reasoning": "å¸‚åœºéœ€æ±‚å¤§ï¼Œè–ªèµ„æ½œåŠ›é«˜",
          "actionItems": ["å­¦ä¹ åç«¯æŠ€æœ¯", "å‚ä¸å…¨æ ˆé¡¹ç›®"]
        }
      ],
      "marketInsights": {
        "demandTrends": "å‰ç«¯å¼€å‘éœ€æ±‚ç¨³å®šå¢é•¿",
        "salaryTrends": "Reactå¼€å‘è€…å¹³å‡è–ªèµ„ä¸Šæ¶¨15%",
        "hotSkills": ["TypeScript", "å¾®å‰ç«¯", "æ€§èƒ½ä¼˜åŒ–"]
      },
      "nextSteps": [
        "å®Œå–„GitHubé¡¹ç›®å±•ç¤º",
        "å‡†å¤‡æŠ€æœ¯é¢è¯•é¢˜åº“",
        "æ›´æ–°LinkedInæ¡£æ¡ˆ"
      ]
    }

    å½“å‰ç®€å†ï¼š
    ${JSON.stringify(this.extractResumeData(resume), null, 2)}

    ç›®æ ‡èŒä½ï¼š
    ${JSON.stringify(targetJobs.map(job => this.extractJobData(job)), null, 2)}
    `;
  }
}
```

## ğŸš¦ ä½¿ç”¨é™åˆ¶ä¸ç›‘æ§

### é€Ÿç‡é™åˆ¶
```typescript
// middleware/rateLimitMiddleware.ts
export class RateLimitService {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  async checkRateLimit(userId: string, action: string): Promise<void> {
    const limits = aiConfig.rateLimits.perUser;
    
    // æ£€æŸ¥å°æ—¶é™åˆ¶
    const hourKey = `rate_limit:${userId}:${action}:${new Date().getHours()}`;
    const hourCount = await this.redis.incr(hourKey);
    if (hourCount === 1) {
      await this.redis.expire(hourKey, 3600);
    }
    if (hourCount > limits.hour) {
      throw new Error('è¶…è¿‡æ¯å°æ—¶è¯·æ±‚é™åˆ¶');
    }
    
    // æ£€æŸ¥æ—¥é™åˆ¶
    const dayKey = `rate_limit:${userId}:${action}:${new Date().getDate()}`;
    const dayCount = await this.redis.incr(dayKey);
    if (dayCount === 1) {
      await this.redis.expire(dayKey, 86400);
    }
    if (dayCount > limits.day) {
      throw new Error('è¶…è¿‡æ¯æ—¥è¯·æ±‚é™åˆ¶');
    }
  }
}
```

### ä½¿ç”¨æƒ…å†µè®°å½•
```typescript
// services/usageTrackingService.ts
export class UsageTrackingService {
  async recordUsage(
    userId: string,
    action: string,
    metadata: {
      tokensUsed?: number;
      success: boolean;
      error?: string;
      processingTime?: number;
    }
  ): Promise<void> {
    await prisma.aiUsage.create({
      data: {
        userId,
        action,
        tokensUsed: metadata.tokensUsed || 0,
        success: metadata.success,
        error: metadata.error,
        processingTime: metadata.processingTime,
        cost: this.calculateCost(action, metadata.tokensUsed),
        createdAt: new Date()
      }
    });
  }
  
  private calculateCost(action: string, tokens: number): number {
    // GPT-4 å®šä»· (å‡è®¾)
    const pricePerToken = 0.00003; // $0.03/1K tokens
    return (tokens || 0) * pricePerToken;
  }
}
```

## ğŸ”§ éƒ¨ç½²å’Œç›‘æ§

### ç¯å¢ƒé…ç½®
```env
# .env
OPENAI_API_KEY=sk-...
OPENAI_ORG_ID=org-...
REDIS_URL=redis://localhost:6379
AI_RATE_LIMIT_ENABLED=true
AI_CACHE_TTL=3600
AI_REQUEST_TIMEOUT=30000
```

### å¥åº·æ£€æŸ¥
```typescript
// routes/health.ts
app.get('/health/ai', async (req, res) => {
  try {
    // æµ‹è¯•OpenAIè¿æ¥
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: 'test' }],
      max_tokens: 5
    });
    
    res.json({
      status: 'healthy',
      services: {
        openai: 'connected',
        redis: await redis.ping() === 'PONG' ? 'connected' : 'disconnected'
      },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```